<!doctype html><html class=scroll-smooth lang=en><head><meta charset=utf-8><link href=/css/style.css rel=stylesheet><link href=/line-awesome/css/line-awesome.min.css rel=stylesheet><script defer src=/js/main.js></script><title>Making `cargo-semver-checks` faster - Google Summer of Code 2025 | </title><body class="bg-white dark:bg-slate-900 transition ease-in-out"><section><div class="sticky top-0 bg-slate-100 dark:bg-slate-800"><div class="container mx-auto flex place-content-between py-16 lg:py-8 font-sans text-6xl lg:text-2xl text-slate-900 dark:text-slate-300"><div class=flex><a class="m-0 p-0 text-slate-900 hover:text-slate-700 dark:text-slate-300 dark:hover:text-slate-200" href=/blog/> /blog </a></div><div class="flex gap-4"><div class="hidden cursor-pointer" id=back-to-top><i class="las la-level-up-alt"></i></div><a href=/><i class="las la-home"></i></a><div class=cursor-pointer id=darkmode-toggle><div class="hidden dark:inline"><i class="las la-sun"></i></div><div class="inline dark:hidden"><i class="las la-moon"></i></div></div></div></div></div><div class="container mb-16"><div class="mt-4 font-serif text-slate-600 dark:text-slate-500 text-4xl lg:text-base">2025-11-09</div><h1 class="w-full mt-4 mb-8 font-serif text-8xl lg:text-4xl text-slate-900 dark:text-slate-300">Making `cargo-semver-checks` faster - Google Summer of Code 2025</h1><div class="w-100 border-t mb-8 border-slate-300 dark:border-slate-700"></div><div class=prose-boring><p>Over the last 6 months I have had the privilege of being a contributor for the Google Summer of Code (GSoC) with The Rust Foundation. In GSoC, contributors work with a mentor and an open source organisation to work on a project of value to the community. My project was to improve the performance of <code>cargo-semver-checks</code> (<code>csc</code>). <code>cargo-semver-checks</code>, if you haven't heard of it, is a <code>cargo</code> plugin that checks rust libraries for SemVer breaking changes. Since the design of <code>csc</code> makes it difficult to analyse performance with traditional external tools, it was an important project goal that, along with implementing performance improvements, I would design and build a tracer that could easily identify performance bottlenecks. Overall, I reduced the typical runtime on very large crates down to ~2s from ~8s - nearly an 80% speedup - without compromising performance on smaller crates. Along the way I reduced test time from ~7min to ~1min.<h2 id=improving-query-performance>Improving Query Performance</h2><ul><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc/pull/98>trustfall-rustdoc#98</a> Improve efficiency of <code>detect_rustdoc_format_version</code>. In the old approach, the entire JSON file, which could be several hundred MB, was parsed using <code>serde</code> to find the format version at the end of the file. This PR adds a fast path that directly skips to the end of the file and checks for the version using string manipulation. This saves up to 1% of total runtime on large crates.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/902>trustfall-rustdoc-adapter#902</a> and <a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/903>trustfall-rustdoc-adapter#903</a> Add a per-item-kind index of public items. This was a follow-up to a 7 month old PR by Predrag that had stalled because of a lack of visibility into the internal behaviour of <code>c-s-c</code>. Improvements were not as good as expected and there was no clear reason why. Using a prototype performance tracer, I was able to identify that the reason for lacking performance was due to not applying to types that underwent type coercion. Along the way, I ran into an API issue where <code>with_capacity</code> is supported for hashmaps using the default hasher, but not with a custom hasher, and implemented a fix. Also interestingly, it was faster to build the index in serial rather than parallel - creating hashmaps in parallel is slow because after the memory is allocated to construct the hashmaps, all the partial hashmaps need to be combined together and the intermediate maps dropped.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/926>trustfall-rustdoc-adapter#926</a> Dynamic resolution of enum variants. Tracing using the prototype tracer identified that there was a particular resolution on five queries that was taking a lot of time. When checking whether two enum variants match, for each enum and variant it will iter through all the variants to find a match. This is actually quadratic in the number of variants per enum, taking O(enum_variants^2) time. After adding an index, it becomes linear, since each variant now exactly matches.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/927>trustfall-rustdoc-adapter#927</a> A small refactoring change to improve readability.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/935>trustfall-rustdoc-adapter#936</a> Adds an experimental performance tracer into <code>trustfall-rustdoc-adapter</code>. This is my last merged change, and underwent several rounds of iteration before it landed on the final design. The goal of the tracer is to be able to identify how long is spent in each resolution with as little overhead as possible.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/1009>trustfall-rustdoc-adapter#1009</a> A work in progress index to reduce the time taken computing the importable path for each property. It currently has neutral performance implications. When resolving the importable paths for a type, it looks them up in an index instead of recomputing. As a side effect, this allows avoiding allocating the vector of paths each time.</p></ul><h2 id=improving-test-performance>Improving Test Performance</h2><p><code>cargo-semver-checks</code> has an exhaustive test suite that runs each lint thousands of times across different test crates for ~250k lints executed. At that number of iterations, even fast operations cause noticeable slowdowns, culminating in a test time of ~7 minutes. Across the following PRs, I reduced that to ~1 minute.<ul><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc/pull/103>trustfall-rustdoc#103</a> Add <code>run_query_with_indexed_query</code> to <code>trustfall-rustdoc</code>. About 60% of test runtime was spent re-parsing GraphQL. This PR adds a new function that allows executing a lint with an already parsed query, avoiding re-parsing for multiple runs.</p><li><p><a href=https://github.com/obi1kenobi/cargo-semver-checks/pull/1371>cargo-semver-checks#1371</a> and <a href=https://github.com/obi1kenobi/cargo-semver-checks/pull/1373>cargo-semver-checks#1373</a> Adds a local cache for each query and uses the newly added function to go from parsing each query six times per lint-crate pair to once per lint - a several hundred time reduction.</p><li><p><a href=https://github.com/obi1kenobi/trustfall-rustdoc-adapter/pull/911>trustfall-rustdoc-adapter#911</a> Lazily initialise and cache the schema once per version instead of reparsing it on-demand. This has a minor beneficial effect in the main execution, but a large effect on test execution where constantly re-parsing the schema took a substantial portion of the test runtime.</p><li><p><a href=https://github.com/obi1kenobi/cargo-semver-checks/pull/1497>cargo-semver-checks#1497</a> By default, when a test fails, <code>insta</code> generates an expression that shows the line of source code that generates the error. However, since tests for <code>c-s-c</code> are generated by macros, there are hundreds of tests that all run from the same file with the same expression: <code>Expression: &query_execution_result</code>. This clearly doesn't provide any meaningful information - every single one of hundreds of tests will have the same expression. Unfortunately, since generating the expression requires waiting for a lock on the source file, when there are multiple failing tests, generation of the expression can take up to ~10-15% of the test runtime for a failing test. This PR removes the generation of the expression, thereby producing a speedup in test times.</p></ul><h2 id=what-s-left-to-do>What's left to do?</h2><p>There are a few things that I couldn't get done over the coding period, but that I would like to work on over the coming years. In no particular order, these include:<ul><li>Add experimental tracing support into <code>cargo-semver-checks</code>.<li>Add an analysis of trace results<li>Design a UI for looking at traces. Currently traces aren't much better than the default <code>Debug</code> implementation.<li>In the far future, it would be nice to have a <code>--perf-report</code> command line flag so that users could easily report performance issues with the data to match.</ul></div></div></section>